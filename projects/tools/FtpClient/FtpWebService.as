import flash.net.FileReference;import flash.net.FileReferenceList;import mx.remoting.*;import mx.rpc.*;import mx.utils.Delegate;class FtpWebService{		//////////////////////////////////////////////////////////////////////////////	////////////////////////// PROPERTIES		// data storage	private var _relativePath:String;	var _currentFtpContent:Array;	var _lastError:String;		// FOR SILEX V1	private var baseUrl:String="../../"; // SILEX root dir	private var downloadUrl:String = "cgi/scripts/download.php";	private var uploadUrl: String = baseUrl+"cgi/scripts/upload.php";		// constants from core.Constants	private var gatewayRelativePath="cgi/gateway.php";	private var initialFtpFolderPath:String="media/";	private var FtpServiceName: String="data_exchange";		var isOnRoot:Boolean = true ;		private var _ftpClient:FtpClient ;		// events	var onLoad:Function;	var itemFunction:Function;	// vars	private var service:Service;					//////////////////////////////////////////////////////////////////////////////	////////////////////////// COMMON METHODS	function FtpWebService(ftpClient)	{				// ****************		// WORKAROUND BUG GATEWAY		// remove extension (.swf)		var _str:String=_root._url.slice(0,_root._url.lastIndexOf("."));		// remove file name (ROOTS)		var path_str:String=_str.slice(0,1+_str.lastIndexOf("/"));		var gatewayUrl:String = path_str+baseUrl+gatewayRelativePath;//"http://localhost/Silex/trunk/cgi/gateway.php";		// ****************				uploadUrl = path_str + uploadUrl ;				service = new Service(gatewayUrl, null, FtpServiceName);		_relativePath="";				_ftpClient = ftpClient ;				_ftpClient.uploadStatus._visible = false ;				trace ( "FtpClient::FtpWebService :: initialization done." ) ;	}				function getRelativePath():String	{		return escape(_relativePath);	}					//list ftp content		function getFtpContent(relativePath:String)	{		_lastError="";		isComputing=true;				// computes new path		switch (relativePath)		{			case "..":			case "../":				var pathNoEndingSlash:String=_relativePath.slice(0,-1);				_relativePath=_relativePath.slice(0,pathNoEndingSlash.lastIndexOf("/")+1);			break;			case ".":			case "./":			break;			default:				_relativePath+=relativePath;								if (_relativePath.slice(-1)!="/") _relativePath+="/";		}		 		 this.isOnRoot = (_relativePath == "") ;		 		var pc:PendingCall = service.listFtpFolderContent(escape( _relativePath));		pc.responder = new RelayResponder(this, "handleGetFtpContent", "handleRemotingError");	}					function handleGetFtpContent(re:ResultEvent)	{		// update data		updateFtpContent(re.result);	}						function updateFtpContent(newFtpContent_array)//:Array) 	{		_currentFtpContent=new Array;				var idx:Number=0;		for ( var item in newFtpContent_array )		{			// call itemFunction to modify the items			var _obj:Object;			if (itemFunction) 				_obj=itemFunction(newFtpContent_array[item]);			else				_obj=newFtpContent_array[item];							// if itemFunction returned an object, lets display it			if (!_obj)			{				continue ;			}						var __obj:Object = {} ;						__obj[_ftpClient.translation.getTranslation("TYPE")] = _obj["item type"] ;			__obj[_ftpClient.translation.getTranslation("NAME")] = _obj["item name"] ;			__obj[_ftpClient.translation.getTranslation("SIZE")] = _obj["item readable size"] ;			__obj[_ftpClient.translation.getTranslation("LAST_MODIFICATION")] = _obj["item last modification date"] ;						_currentFtpContent.addItem(__obj);			idx++;		}		_lastError="";				// call the callback function		if (onLoad) onLoad(true);		isComputing=false;	}					function handleRemotingError( fault:FaultEvent ):Void 	{		// update data		_currentFtpContent=null;		_lastError=" "+fault.fault.faultstring;				// call the callback function		if (onLoad) onLoad(false);				getFtpContent("."); 		isComputing=false;	}				//////////////////////////////////////////////////////////////////////////////	////////////////////////// CREATE DIRECTORY METHODS		/**	 * Create a new folder with name_str as name	 */	function createFolder(name_str:String)	{		var pc:PendingCall = service.createFtpFolder(getRelativePath(), escape(name_str));		pc.responder = new RelayResponder(this, "handleCreateFolder", "handleRemotingError");		_lastError="";		isComputing=true;	}		function handleCreateFolder(re:ResultEvent)	{		switch ( re.result )		{			case "DONE":				getFtpContent(".");				break;			default:				_ftpClient.displayError ( _ftpClient.translation.getTranslation("ERROR_CREATING_DIR") , String(re.result), true  );				break;		}			}					//////////////////////////////////////////////////////////////////////////////	////////////////////////// DOWNLOAD FILE METHODS			// *******************************************	// download	function downloadFile(fileName_str:String)	{		if (!fileName_str) return;		var _lv:LoadVars=new LoadVars;		_lv.initial_name=initialFtpFolderPath+getRelativePath()+fileName_str;//		_lv.final_name=fileName_str;		_lv.send(baseUrl+downloadUrl,"_self");	}		//////////////////////////////////////////////////////////////////////////////	////////////////////////// RENAME ITEM METHODS		//rename a file or folder		function renameItem(initial_name:String, final_name_str:String)	{		var pc:PendingCall = service.renameFtpItem(getRelativePath(), escape(initial_name), escape(final_name_str));		pc.responder = new RelayResponder(this, "handleRename", "handleRemotingError");		_lastError="";		isComputing=true;	}		function handleRename(re:ResultEvent)	{		isComputing=false;		switch ( re.result )		{			case "DONE":				getFtpContent(".");				break;			default:				_ftpClient.displayError ( _ftpClient.translation.getTranslation("ERROR_RENAMING_ITEM") , String(re.result), true );				break;		}			}					//////////////////////////////////////////////////////////////////////////////	////////////////////////// DELETE FILE METHODS		//rename a file or folder		function deleteItem(name_str:String)	{		var pc:PendingCall = service.deleteFtpItem(getRelativePath(), escape(name_str));		pc.responder = new RelayResponder(this, "handleDelete", "handleRemotingError");		_lastError="";		isComputing=true;	}	function handleDelete(re:ResultEvent)	{		getFtpContent(".");	}	function trace(str)
	{
		_root.debug_str = str+"<br>"+_root.debug_str;
	}		#include "upload.as"}