<haxe>
	<class path="Enum" params="T" file="C:\Motion-Twin\haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="haxe.io.BytesBuffer" params="" file="C:\Motion-Twin\haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="String"/></b>
		<addByte public="1" get="inline" set="null" line="55"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="69"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="84"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="106">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.Input" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<readByte public="1" set="method" line="35"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="44"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="65"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="68"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readAll public="1" set="method" line="75"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="96"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="104"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="116"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="124"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="141"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="155"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="169"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="176"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="185"><f a=""><c path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="191"><f a=""><c path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="201"><f a=""><c path="Int"/></f></readUInt24>
		<readInt31 public="1" set="method" line="208"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" set="method" line="225"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" set="method" line="234"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" set="method" line="242"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>
	An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.
</haxe_doc>
	</class>
	<typedef path="org.silex.core.seo.LayerSeoAggregatedModel" params="" file="../../framework/hx/org/silex/core/seo/LayerSeoAggregatedModel.hx">
		<a>
			<title><c path="String"/></title>
			<tags><c path="String"/></tags>
			<subLayers><c path="Array"><t path="org.silex.core.seo.ComponentSeoLinkModel"/></c></subLayers>
			<links><c path="String"/></links>
			<htmlEquivalent><c path="String"/></htmlEquivalent>
			<description><c path="String"/></description>
			<deeplink><c path="String"/></deeplink>
		</a>
		<haxe_doc>
 * class used to describe the aggregated layer seo structure for a single deeplink.
 * the aggregated layer seo structure is generated by grouping all component seo data of the corresponding layerSeoModel
 * 
 * @author	Raphael Harmel
 * @version 1.0
 * @date   2011-07-12
 </haxe_doc>
	</typedef>
	<class path="php.NativeArray" params="" file="C:\Motion-Twin\haxe/std/php/NativeArray.hx" extern="1"/>
	<typedef path="org.silex.core.seo.ComponentSeoLinkModel" params="" file="../../framework/hx/org/silex/core/seo/ComponentSeoLinkModel.hx">
		<a>
			<title><c path="String"/></title>
			<description><c path="String"/></description>
			<deeplink><c path="String"/></deeplink>
		</a>
		<haxe_doc><![CDATA[
 * class used to store all components of a specific layer & deeplink. Accessors should be kept as is.
 * 
 * @author	Raphael Harmel
 * @version 1.0
 * @date   2011-05-25
 ]]></haxe_doc>
	</typedef>
	<class path="StringTools" params="" file="C:\Motion-Twin\haxe/std/php/_std/StringTools.hx">
		<urlEncode public="1" get="inline" set="null" line="28" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" get="inline" set="null" line="32" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="36" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" get="inline" set="null" line="40" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="44" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="48" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="54" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" get="inline" set="null" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" get="inline" set="null" line="63" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" get="inline" set="null" line="67" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" get="inline" set="null" line="71" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" get="inline" set="null" line="75" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" get="inline" set="null" line="79" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="83" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="90" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="94" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<enum path="XmlType" params="" file="C:\Motion-Twin\haxe/std/php/_std/Xml.hx" module="Xml"/>
	<class path="EReg" params="" file="C:\Motion-Twin\haxe/std/php/_std/EReg.hx">
		<r><d/></r>
		<last><c path="String"/></last>
		<global><e path="Bool"/></global>
		<pattern><c path="String"/></pattern>
		<options><c path="String"/></options>
		<re><c path="String"/></re>
		<matches><c path="ArrayAccess"><d/></c></matches>
		<match public="1" set="method" line="46">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" set="method" line="55">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="69">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="75">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" set="method" line="79">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" set="method" line="83">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" set="method" line="90">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" set="method" line="36"><f a="r:opt">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="Xml" params="" file="C:\Motion-Twin\haxe/std/php/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<build static="1"><c path="Xml"/></build>
		<__start_element_handler set="method" line="52" static="1"><f a="parser:name:attribs">
	<d/>
	<c path="String"/>
	<c path="ArrayAccess"><c path="String"/></c>
	<e path="Void"/>
</f></__start_element_handler>
		<__end_element_handler set="method" line="59" static="1"><f a="parser:name">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__end_element_handler>
		<__character_data_handler set="method" line="63" static="1"><f a="parser:data">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__character_data_handler>
		<__default_handler set="method" line="75" static="1"><f a="parser:data">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__default_handler>
		<xmlChecker line="79" static="1"><c path="EReg"/></xmlChecker>
		<parse public="1" set="method" line="81" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="114" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="123" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="130" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="137" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="144" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" line="151" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" line="158" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><c path="Hash"><c path="String"/></c></_attributes>
		<_children><c path="Array"><c path="Xml"/></c></_children>
		<_parent><c path="Xml"/></_parent>
		<getNodeName set="method" line="165"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method" line="171"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue set="method" line="177"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method" line="183"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent set="method" line="189"><f a=""><c path="Xml"/></f></getParent>
		<get public="1" set="method" line="193">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1" set="method" line="199">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1" set="method" line="205">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1" set="method" line="211">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="217">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="223">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="240">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="276">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="313">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="319">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="332">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="339">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="347">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="354">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<new set="method" line="112"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<class path="Reflect" params="" file="C:\Motion-Twin\haxe/std/php/_std/Reflect.hx">
		<hasField public="1" get="inline" set="null" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" set="method" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="36" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" set="method" line="40" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="49" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="58" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="62" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="66" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="74" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="83" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="89" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="97" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="C:\Motion-Twin\haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="org.silex.core.seo.LayerSeo" params="" file="../../framework/hx/org/silex/core/seo/LayerSeo.hx">
		<SEO_DATA_NODE_NAME line="29" static="1"><c path="String"/></SEO_DATA_NODE_NAME>
		<VERSION_ATTRIBUTE_NAME line="30" static="1"><c path="String"/></VERSION_ATTRIBUTE_NAME>
		<VERSION_ATTRIBUTE_VALUE line="31" static="1"><c path="String"/></VERSION_ATTRIBUTE_VALUE>
		<LAYER_SEO_NODE_NAME line="32" static="1"><c path="String"/></LAYER_SEO_NODE_NAME>
		<DEEPLINK_ATTRIBUTE_NAME line="33" static="1"><c path="String"/></DEEPLINK_ATTRIBUTE_NAME>
		<COMPONENTS_NODE_NAME get="inline" set="null" line="34" static="1"><c path="String"/></COMPONENTS_NODE_NAME>
		<CONTENT_NODE_NAME line="36" static="1"><c path="String"/></CONTENT_NODE_NAME>
		<COMPONENT_NODE_NAME get="inline" set="null" line="37" static="1"><c path="String"/></COMPONENT_NODE_NAME>
		<LINKS_NODE_NAME line="38" static="1"><c path="String"/></LINKS_NODE_NAME>
		<LINK_NODE_NAME get="inline" set="null" line="39" static="1"><c path="String"/></LINK_NODE_NAME>
		<read public="1" set="method" line="48" static="1">
			<f a="fileName:?deeplink">
				<c path="String"/>
				<c path="String"/>
				<c path="php.NativeArray"/>
			</f>
			<haxe_doc>
	 * reads a seo file and returns the Php Native Array LayerSeoModel equivalent for the corresponding deeplink.
	 * 
	 * inputs: a seo file, a deeplink
	 * output: Php Native Array LayerSeoModel equivalent
	 </haxe_doc>
		</read>
		<readLayerSeoModel public="1" set="method" line="70" static="1">
			<f a="fileName:?deeplink">
				<c path="String"/>
				<c path="String"/>
				<t path="org.silex.core.seo.LayerSeoModel"/>
			</f>
			<haxe_doc>
	 * reads a xml seo file and returns the LayerSeoModel equivalent for the corresponding deeplink.
	 * 
	 * inputs: a seo file, a deeplink
	 * output: LayerSeoModel equivalent
	 </haxe_doc>
		</readLayerSeoModel>
		<readXml public="1" set="method" line="94" static="1">
			<f a="fileName:?deeplink">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
	 * reads a seo file and returns the XML content without indent for a specific deeplink.
	 * 
	 * inputs: a seo file, a deeplink
	 * output: an un-indented layerSeo XML
	 </haxe_doc>
		</readXml>
		<xml2LayerSeoModel public="1" set="method" line="133" static="1">
			<f a="xml">
				<c path="Xml"/>
				<t path="org.silex.core.seo.LayerSeoModel"/>
			</f>
			<haxe_doc>
	 * converts a seo xml to a LayerSeoModel.
	 * 
	 * inputs: a seo xml
	 * output: a LayerSeoModel
	 </haxe_doc>
		</xml2LayerSeoModel>
		<layerSeoModel2PhpArray public="1" set="method" line="236" static="1">
			<f a="layerSeoModel">
				<t path="org.silex.core.seo.LayerSeoModel"/>
				<c path="php.NativeArray"/>
			</f>
			<haxe_doc>
	 * converts a LayerSeoModel to a Php Native Array.
	 * 
	 * inputs: a LayerSeoModel
	 * output: an Php Native Array
	 </haxe_doc>
		</layerSeoModel2PhpArray>
		<write public="1" set="method" line="318" static="1">
			<f a="fileName:deeplink:layerSeoModelArray:indent">
				<c path="String"/>
				<c path="String"/>
				<c path="php.NativeArray"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * writes a Layer Seo to the layer seo xml file with the deeplink as attribute.
	 * 
	 * inputs: a layer file name, a deeplink, a LayerSeoModel php NativeArray, an indent boolean
	 * output: nothing
	 </haxe_doc>
		</write>
		<writeLayerSeoModel public="1" set="method" line="338" static="1"><f a="fileName:deeplink:layerSeoModel:indent">
	<c path="String"/>
	<c path="String"/>
	<t path="org.silex.core.seo.LayerSeoModel"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></writeLayerSeoModel>
		<phpArray2LayerSeoModel public="1" set="method" line="350" static="1">
			<f a="layerSeoArray:deeplink">
				<c path="php.NativeArray"/>
				<c path="String"/>
				<t path="org.silex.core.seo.LayerSeoModel"/>
			</f>
			<haxe_doc>
	 * converts a PHP array to a LayerSeoModel.
	 * 
	 * inputs: a PHP array, a deeplink
	 * output: an LayerSeoModel
	 </haxe_doc>
		</phpArray2LayerSeoModel>
		<layerSeoModel2Xml public="1" set="method" line="432" static="1">
			<f a="layerSeoModel:deeplink">
				<t path="org.silex.core.seo.LayerSeoModel"/>
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
	 * converts a LayerSeoModel to an XML.
	 * 
	 * inputs: a LayerSeoModel, a deeplink
	 * output: an XML
	 </haxe_doc>
		</layerSeoModel2Xml>
		<writeXml public="1" set="method" line="533" static="1">
			<f a="fileName:deeplink:xmlContent:indent">
				<c path="String"/>
				<c path="String"/>
				<c path="Xml"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * writes/replaces the deeplink layerSeo xml into the layer seo xml file.
	 * 
	 * inputs: a layer file name, a deeplink, a LayerSeoModel xml, an indent boolean
	 * output: nothing
	 </haxe_doc>
		</writeXml>
		<haxe_doc><![CDATA[
 * class used to read & write a seo.xml v2 file to/from a LayerSeoModel.
 * 
 * @author	Raphael Harmel
 * @version 1.0
 * @date   2011-05-25
 ]]></haxe_doc>
	</class>
	<class path="org.silex.serverApi.externs.ServerConfigExtern" params="" file="../../framework/hx/org/silex/serverApi/externs/ServerConfigExtern.hx" extern="1">
		<silex_server_ini public="1">
			<c path="php.NativeArray"/>
			<haxe_doc><![CDATA[
	*  A php.NativeArray used to store the server's configuration.<br/>
	*  Used as a HashTable of String's.
	]]></haxe_doc>
		</silex_server_ini>
		<silex_client_ini public="1">
			<c path="php.NativeArray"/>
			<haxe_doc><![CDATA[
	*  A php.NativeArray used to store the client's configuration. These properties are sent to the client.<br/>
	*  Used as a HashTable of String's.
	]]></haxe_doc>
		</silex_client_ini>
		<admin_write_ok public="1">
			<c path="php.NativeArray"/>
			<haxe_doc>
	*  Stores a list of files and folders that can be written by a user with Admin Role.
	</haxe_doc>
		</admin_write_ok>
		<admin_read_ok public="1">
			<c path="php.NativeArray"/>
			<haxe_doc>
	*  Stores a list of files and folders that can be read by a user with Admin Role.
	</haxe_doc>
		</admin_read_ok>
		<user_write_ok public="1">
			<c path="php.NativeArray"/>
			<haxe_doc>
	*  Stores a list of files and folders that can written by a user with User Role.
	</haxe_doc>
		</user_write_ok>
		<user_read_ok public="1">
			<c path="php.NativeArray"/>
			<haxe_doc>
	*  Stores a list of files and folders that can be read by a user User Role.
	</haxe_doc>
		</user_read_ok>
		<sepCharForDeeplinks public="1">
			<c path="php.NativeString"/>
			<haxe_doc>
	*  The character used to replace spaces in URLs.
	</haxe_doc>
		</sepCharForDeeplinks>
		<getContentFolderForPublication public="1" set="method">
			<f a="id_site">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[
	*  Returns the String representing the content folder of the publication which id is given as parameter.<br/>
	*  For example it may return "contents/".<br/>
	*  Values of CONTENTS_THEMES_FOLDER, CONTENTS_UTILITIES_FOLDER and CONTENT_FOLDER are set in
	*  conf/silex_server.ini.
	]]></haxe_doc>
		</getContentFolderForPublication>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
*  This is an extern class binded to server_config.
</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\Motion-Twin\haxe/std/php/_std/StringBuf.hx">
		<b><c path="String"/></b>
		<add public="1" get="inline" set="null" line="33">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="37">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="41">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="45">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="php.Boot" params="" file="C:\Motion-Twin\haxe/std/php/Boot.hx">
		<qtypes static="1"><c path="Array"><unknown/></c></qtypes>
		<ttypes static="1"><unknown/></ttypes>
		<tpaths static="1"><unknown/></tpaths>
		<skip_constructor line="7" static="1"><e path="Bool"/></skip_constructor>
	</class>
	<class path="haxe.Int32" params="" file="C:\Motion-Twin\haxe/std/haxe/Int32.hx">
		<make public="1" get="inline" set="null" line="33" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" get="inline" set="null" line="41" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<toInt public="1" get="inline" set="null" line="49" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<toNativeInt public="1" get="inline" set="null" line="62" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<add public="1" get="inline" set="null" line="70" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" get="inline" set="null" line="78" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="86" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" get="inline" set="null" line="94" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" get="inline" set="null" line="102" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="110" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="118" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="126" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="134" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" get="inline" set="null" line="142" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" get="inline" set="null" line="150" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="158" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<complement public="1" get="inline" set="null" line="166" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" get="inline" set="null" line="174" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
	</class>
	<class path="org.silex.core.AccessorManager" params="" file="../../framework/hx/org/silex/core/AccessorManager.hx">
		<_instance static="1"><c path="org.silex.core.AccessorManager"/></_instance>
		<_accessorSeparator static="1"><c path="String"/></_accessorSeparator>
		<getInstance public="1" set="method" line="70" static="1"><f a="idSite">
	<c path="String"/>
	<c path="org.silex.core.AccessorManager"/>
</f></getInstance>
		<splitTags public="1" set="method" line="87" static="1">
			<f a="inputString:?leftTag:?rightTag">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
	 * Use the accessors delimiters paterns to split the input string into an array.
	 * 
	 * @param	inputString	a string containing accessors
	 * @param	leftTag		[[optional]]left delimiter, (( by default
	 * @param	rightTag	[[optional]]right delimiter, )) by default
	 * @return	the array of strings containing accessors
	 </haxe_doc>
		</splitTags>
		<splitAndRevealTags public="1" set="method" line="157" static="1">
			<f a="inputString:accessorsList:?leftTag:?rightTag">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc><![CDATA[
	 * Use the accessors delimiters paterns to split the input string into an array and reveal the accessors in it.
	 * 
	 * @param	inputString	a string containing accessors
	 * @param	leftTag		[[optional]]left delimiter, << by default
	 * @param	rightTag	[[optional]]right delimiter, >> by default
	 * @return	the array of strings containing accessors
	 ]]></haxe_doc>
		</splitAndRevealTags>
		<getTarget public="1" set="method" line="217" static="1">
			<f a="pathString:accessorsList">
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>
	 * Retrieves a Dynamic from its path
	 * This Haxe version is a light version of the as2 org.silex.core.Utils.getTarget one, because it is used only by seo
	 * 
	 * @param	pathString		the target path
	 * @param	accessorsList	the accessors list used to reveal the accessor
	 * @return the targeted Dynamic
	 </haxe_doc>
		</getTarget>
		<revealAccessors public="1" set="method" line="264" static="1">
			<f a="toBeRevealed:accessorsList">
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<haxe_doc><![CDATA[
	 * Takes toBeRevealed string and resolves its accessors using accessorsList.
	 * "Resolve" means to replace each accessor by its equivalent string value.
	 * 
	 * example1:
	 * 		if accessor is '<<DataSelector1.selectedItem.title>>'
	 * 		and accessorsList:{DataSelector1=>selectedItem=>title:"layer1",silex.config=>version:"v1.6.1"},
	 * 			=> result will be 'layer1'
	 * example2:
	 * 		"my text is for <<dbdata.name1>>!!! not for <<dbdata.name2>> ((nor for <<dbdata.name3>>!!!))" becomes
	 * 			=> "my text is for valueName1!!! not for valueName2 nor for valueName3!!!" if all name variables exist
	 * 			=> "my text is for valueName1!!! not for valueName2" if only dbdata.name1 & dbdata.name2 exists
	 * 			=> "" if only dbdata.name1 or dbdata.name2 exists
	 * 			=> "nor for valueName3!!!" if only dbdata.name3 exists
	 * 
	 * @param	toBeRevealed		the string to be revealed, containing accessors ("((...<<path.to.a.variable>>...))")
	 * @param	accessorsList		the accessors list used to reveal the accessor
	 * @return	Dynamic				the resolved accessor, which can be a string, an array<Dynamic> or a Hash<Dynamic>
	 ]]></haxe_doc>
		</revealAccessors>
		<accessors public="1"><d/></accessors>
		<new set="method" line="34"><f a="idSite">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * Class managing accessors resolution
 * 
 * @author Raphael Harmel
 * @version 1.0
 * @date   2011-06-15
 </haxe_doc>
	</class>
	<class path="org.silex.serverApi.RootDir" params="" file="../../framework/hx/org/silex/serverApi/RootDir.hx">
		<rootPath public="1" get="getRootPath" set="null" static="1">
			<c path="String"/>
			<haxe_doc>
	*  The Root Path of the SILEX Server
	</haxe_doc>
		</rootPath>
		<rootUrl public="1" get="getRootUrl" set="null" static="1"><c path="String"/></rootUrl>
		<getRootPath set="method" line="30" static="1"><f a=""><c path="String"/></f></getRootPath>
		<getRootUrl set="method" line="39" static="1"><f a=""><c path="String"/></f></getRootUrl>
	</class>
	<class path="org.silex.core.seo.Constants" params="" file="../../framework/hx/org/silex/core/seo/Constants.hx">
		<SEO_FILE_EXTENSION public="1" get="inline" set="null" line="21" static="1"><c path="String"/></SEO_FILE_EXTENSION>
		<LAYER_SEO_PROPERTIES public="1" get="inline" set="null" line="24" static="1"><c path="Array"><c path="String"/></c></LAYER_SEO_PROPERTIES>
		<COMPONENT_GENERIC_PROPERTIES public="1" get="inline" set="null" line="27" static="1"><c path="Array"><c path="String"/></c></COMPONENT_GENERIC_PROPERTIES>
		<COMPONENT_LINK_PROPERTIES public="1" get="inline" set="null" line="30" static="1"><c path="Array"><c path="String"/></c></COMPONENT_LINK_PROPERTIES>
		<LAYER_SEO_AGGREGATED_PROPERTIES public="1" line="33" static="1"><c path="Array"><c path="String"/></c></LAYER_SEO_AGGREGATED_PROPERTIES>
		<CHILD_LAYERS_NODE_NAME public="1" line="34" static="1"><c path="String"/></CHILD_LAYERS_NODE_NAME>
		<haxe_doc>
 * class used to gather all seo constants
 * 
 * @author	Raphael Harmel
 * @version 1.0
 * @date   2011-07-12
 </haxe_doc>
	</class>
	<class path="haxe.io.Output" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Output.hx">
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<writeByte public="1" set="method" line="37"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="41"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="64"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="67"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="70"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<write public="1" set="method" line="77"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<writeFullBytes public="1" set="method" line="88"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" set="method" line="96"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="108"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="120"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="126"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="131"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" set="method" line="142"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" set="method" line="147"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt31 public="1" set="method" line="160"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt30 public="1" set="method" line="177"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt32 public="1" set="method" line="192"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="212">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.
	</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="215"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<writeString public="1" set="method" line="237"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<haxe_doc>
	An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.
</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="211" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="239" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="278" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<getData public="1" get="inline" set="null" line="207"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Date" params="" file="C:\Motion-Twin\haxe/std/php/_std/Date.hx">
		<now public="1" set="method" line="75" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromPhpTime set="method" line="79" static="1"><f a="t">
	<c path="Float"/>
	<c path="Date"/>
</f></fromPhpTime>
		<fromTime public="1" set="method" line="85" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="91" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<__t><c path="Float"/></__t>
		<getTime public="1" set="method" line="34">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getPhpTime set="method" line="38"><f a=""><c path="Float"/></f></getPhpTime>
		<getFullYear public="1" set="method" line="42">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method" line="46">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method" line="51">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getHours public="1" set="method" line="55">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method" line="59">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method" line="63">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getDay public="1" set="method" line="67">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method" line="71">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a="year:month:day:hour:min:sec">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="IntIter" params="" file="C:\Motion-Twin\haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="org.silex.serverApi.externs.SiteEditorExtern" params="" file="../../framework/hx/org/silex/serverApi/externs/SiteEditorExtern.hx" extern="1">
		<getSectionSeoData public="1" set="method">
			<f a="id_site:deeplink:?urlBase">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="php.NativeArray"/>
			</f>
			<haxe_doc><![CDATA[
	*  Finds and returns SEO informations about a page.<br/>
	*  If several layers are composing the deeplink all data are merged.
	]]></haxe_doc>
		</getSectionSeoData>
		<writeSectionData public="1" set="method">
			<f a="xmlData:xmlFileName:sectionName:id_site:seoObject:domObject">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="php.NativeArray"/>
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Writes xmlData into xmlFileName.
	</haxe_doc>
		</writeSectionData>
		<storeSeoData public="1" set="method">
			<f a="websiteContentFolderPath:sectionName:seoObject">
				<c path="String"/>
				<c path="String"/>
				<c path="php.NativeArray"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Stores seo data from seoObject in the file corresponding to sectionName and websiteContentFolderPath.
	</haxe_doc>
		</storeSeoData>
		<operateSection set="method">
			<f a="siteName:oldSectionName:newSectionName:action">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Called by duplicateSection, renameSection...
	</haxe_doc>
		</operateSection>
		<renameSection public="1" set="method">
			<f a="siteName:oldSectionName:newSectionName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Renames oldSectionName in siteName to newSectionName.
	</haxe_doc>
		</renameSection>
		<duplicateSection public="1" set="method">
			<f a="siteName:oldSectionName:newSectionName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Duplicates oldSectionName from siteName to newSectionName.
	</haxe_doc>
		</duplicateSection>
		<createSection public="1" set="method">
			<f a="siteName:newSectionName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Creates newSectionName in siteName.
	</haxe_doc>
		</createSection>
		<deleteSection public="1" set="method">
			<f a="siteName:sectionName">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*  Deletes sectionName in siteName.
	</haxe_doc>
		</deleteSection>
		<savePublicationStructure public="1" set="method">
			<f a="siteName:xmlContent:xmlContentPublished">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Saves xmlContent and xmlContentPublished into the corresponding files depending on siteName.
	</haxe_doc>
		</savePublicationStructure>
		<loadPublicationStructure public="1" set="method">
			<f a="siteName:?isPublishedVersion">
				<c path="String"/>
				<e path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Loads and returns either the published version or the unpublished version of PublicationStructure of siteName.
	</haxe_doc>
		</loadPublicationStructure>
		<parse_client_site_ini_file public="1" set="method">
			<f a="filePath">
				<c path="String"/>
				<c path="php.NativeArray"/>
			</f>
			<haxe_doc>
	*  Do not use, we are trying to get rid of it.
	</haxe_doc>
		</parse_client_site_ini_file>
		<getWebsiteConfig public="1" set="method">
			<f a="id_site:?mergeWithServerConfig">
				<c path="String"/>
				<e path="Bool"/>
				<c path="php.NativeArray"/>
			</f>
			<haxe_doc>
	*  Return's id_site's configuration.
	</haxe_doc>
		</getWebsiteConfig>
		<deleteWebsite public="1" set="method">
			<f a="id_site">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Delete the whole id_site Website (Publication).
	</haxe_doc>
		</deleteWebsite>
		<createWebsite public="1" set="method">
			<f a="id_site">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Creates a new website (Publication) named id_site.
	</haxe_doc>
		</createWebsite>
		<renameWebsite public="1" set="method">
			<f a="id_site:new_id">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Renames website (Publication) from id_site to new_id.
	</haxe_doc>
		</renameWebsite>
		<writeWebsiteConfig public="1" set="method">
			<f a="websiteInfo:id_site">
				<c path="php.NativeArray"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Saves websiteInfo.
	</haxe_doc>
		</writeWebsiteConfig>
		<duplicateWebsite public="1" set="method">
			<f a="id_site:newName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Duplicates id_site as newName.
	</haxe_doc>
		</duplicateWebsite>
		<doDuplicateWebsite set="method">
			<f a="folder:newFolder">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Called by duplicateWebsite.
	</haxe_doc>
		</doDuplicateWebsite>
		<getSiteThumb public="1" set="method">
			<f a="siteName">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
	*  Return type is Dynamic since it can be a php.NativeArray or a String in case of error.
	</haxe_doc>
		</getSiteThumb>
		<getPagePreview public="1" set="method">
			<f a="siteName:pageName">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
	*  Return type is Dynamic since it can be a php.NativeArray or a String in case of error.
	</haxe_doc>
		</getPagePreview>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="php.Lib" params="" file="C:\Motion-Twin\haxe/std/php/Lib.hx">
		<print public="1" set="method" line="7" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output.
	</haxe_doc>
		</print>
		<println public="1" set="method" line="14" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output followed by a newline character.
	</haxe_doc>
		</println>
		<dump public="1" set="method" line="19" static="1"><f a="v">
	<d/>
	<e path="Void"/>
</f></dump>
		<serialize public="1" set="method" line="27" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize using native PHP serialization. This will return a Binary string that can be
		stored for long term usage.
	</haxe_doc>
		</serialize>
		<unserialize public="1" set="method" line="34" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native PHP serialization. See [serialize].
	</haxe_doc>
		</unserialize>
		<extensionLoaded public="1" set="method" line="38" static="1"><f a="name">
	<c path="String"/>
	<unknown/>
</f></extensionLoaded>
		<isCli public="1" set="method" line="42" static="1"><f a=""><e path="Bool"/></f></isCli>
		<printFile public="1" set="method" line="46" static="1"><f a="file">
	<c path="String"/>
	<unknown/>
</f></printFile>
		<toPhpArray public="1" get="inline" set="null" line="50" static="1"><f a="a">
	<c path="Array"><d/></c>
	<c path="php.NativeArray"/>
</f></toPhpArray>
		<toHaxeArray public="1" get="inline" set="null" line="54" static="1"><f a="a">
	<c path="php.NativeArray"/>
	<c path="Array"><d/></c>
</f></toHaxeArray>
		<hashOfAssociativeArray public="1" params="T" set="method" line="58" static="1"><f a="arr">
	<c path="php.NativeArray"/>
	<c path="Hash"><c path="hashOfAssociativeArray.T"/></c>
</f></hashOfAssociativeArray>
		<associativeArrayOfHash public="1" set="method" line="64" static="1"><f a="hash">
	<c path="Hash"><d/></c>
	<c path="php.NativeArray"/>
</f></associativeArrayOfHash>
		<rethrow public="1" set="method" line="71" static="1">
			<f a="e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		For neko compatibility only.
	</haxe_doc>
		</rethrow>
		<appendType set="method" line="79" static="1"><f a="o:path:t">
	<d/>
	<c path="Array"><c path="String"/></c>
	<d/>
	<e path="Void"/>
</f></appendType>
		<getClasses public="1" set="method" line="90" static="1"><f a=""><a/></f></getClasses>
		<loadLib public="1" set="method" line="104" static="1">
			<f a="pathToLib">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*  Loads types defined in the specified directory.
 	</haxe_doc>
		</loadLib>
	</class>
	<class path="php.Web" params="" file="C:\Motion-Twin\haxe/std/php/Web.hx">
		<getParams public="1" set="method" line="14" static="1">
			<f a=""><c path="Hash"><unknown/></c></f>
			<haxe_doc>
		Returns the GET and POST parameters.
	</haxe_doc>
		</getParams>
		<getParamValues public="1" set="method" line="42" static="1">
			<f a="param">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns an Array of Strings built using GET / POST values.
		If you have in your URL the parameters [a[]=foo;a[]=hello;a[5]=bar;a[3]=baz] then
		[php.Web.getParamValues("a")] will return [["foo","hello",null,"baz",null,"bar"]]
	</haxe_doc>
		</getParamValues>
		<getHostName public="1" get="inline" set="null" line="81" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the local server host name
	</haxe_doc>
		</getHostName>
		<getClientIP public="1" get="inline" set="null" line="88" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Surprisingly returns the client IP address.
	</haxe_doc>
		</getClientIP>
		<getURI public="1" set="method" line="95" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the original request URL (before any server internal redirections)
	</haxe_doc>
		</getURI>
		<redirect public="1" set="method" line="103" static="1">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Tell the client to redirect to the given url ("Location" header)
	</haxe_doc>
		</redirect>
		<setHeader public="1" get="inline" set="null" line="111" static="1">
			<f a="h:v">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an output header value. If some data have been printed, the headers have
		already been sent so this will raise an exception.
	</haxe_doc>
		</setHeader>
		<setReturnCode public="1" set="method" line="119" static="1">
			<f a="r">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the HTTP return code. Same remark as setHeader.
		See status code explanation here: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
	</haxe_doc>
		</setReturnCode>
		<getClientHeader public="1" set="method" line="170" static="1">
			<f a="k">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Retrieve a client header value sent with the request.
	</haxe_doc>
		</getClientHeader>
		<_client_headers static="1"><c path="List"><a>
	<value><c path="String"/></value>
	<header><c path="String"/></header>
</a></c></_client_headers>
		<getClientHeaders public="1" set="method" line="185" static="1">
			<f a=""><c path="List"><a>
	<value><c path="String"/></value>
	<header><c path="String"/></header>
</a></c></f>
			<haxe_doc>
		Retrieve all the client headers.
	</haxe_doc>
		</getClientHeaders>
		<getParamsString public="1" get="inline" set="null" line="201" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns all the GET parameters String
	</haxe_doc>
		</getParamsString>
		<getPostData public="1" set="method" line="213" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns all the POST data. POST Data is always parsed as
		being application/x-www-form-urlencoded and is stored into
		the getParams hashtable. POST Data is maximimized to 256K
		unless the content type is multipart/form-data. In that
		case, you will have to use [getMultipart] or [parseMultipart]
		methods.
	</haxe_doc>
		</getPostData>
		<getCookies public="1" set="method" line="231" static="1">
			<f a=""><c path="Hash"><unknown/></c></f>
			<haxe_doc>
		Returns an hashtable of all Cookies sent by the client.
		Modifying the hashtable will not modify the cookie, use setCookie instead.
	</haxe_doc>
		</getCookies>
		<setCookie public="1" set="method" line="239" static="1">
			<f a="key:value:?expire:?domain:?path:?secure">
				<c path="String"/>
				<c path="String"/>
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a Cookie value in the HTTP headers. Same remark as setHeader.
	</haxe_doc>
		</setCookie>
		<addPair set="method" line="247" static="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></addPair>
		<getAuthorization public="1" set="method" line="255" static="1">
			<f a=""><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></f>
			<haxe_doc>
		Returns an object with the authorization sent by the client (Basic scheme only).
	</haxe_doc>
		</getAuthorization>
		<getCwd public="1" get="inline" set="null" line="264" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Get the current script directory in the local filesystem.
	</haxe_doc>
		</getCwd>
		<getMultipart public="1" set="method" line="272" static="1">
			<f a="maxSize">
				<c path="Int"/>
				<c path="Hash"><c path="String"/></c>
			</f>
			<haxe_doc>
		Get the multipart parameters as an hashtable. The data
		cannot exceed the maximum size specified.
	</haxe_doc>
		</getMultipart>
		<parseMultipart public="1" set="method" line="301" static="1">
			<f a="onPart:onData">
				<f a=":">
					<c path="String"/>
					<c path="String"/>
					<e path="Void"/>
				</f>
				<f a="::">
					<c path="haxe.io.Bytes"/>
					<c path="Int"/>
					<c path="Int"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Parse the multipart data. Call [onPart] when a new part is found
		with the part name and the filename if present
		and [onData] when some part data is readed. You can this way
		directly save the data on hard drive in the case of a file upload.
	</haxe_doc>
		</parseMultipart>
		<flush public="1" get="inline" set="null" line="352" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Flush the data sent to the client. By default on Apache, outgoing data is buffered so
		this can be useful for displaying some long operation progress.
	</haxe_doc>
		</flush>
		<getMethod public="1" set="method" line="359" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Get the HTTP method used by the client.
	</haxe_doc>
		</getMethod>
		<isModNeko public="1" set="null" static="1"><e path="Bool"/></isModNeko>
		<haxe_doc>
	This class is used for accessing the local Web server and the current
	client request and informations.
</haxe_doc>
	</class>
	<enum path="php.io.FileHandle" params="" file="C:\Motion-Twin\haxe/std/php/io/File.hx" module="php.io.File"/>
	<enum path="php.io.FileSeek" params="" file="C:\Motion-Twin\haxe/std/php/io/File.hx" module="php.io.File">
		<SeekEnd/>
		<SeekCur/>
		<SeekBegin/>
	</enum>
	<class path="php.io.File" params="" file="C:\Motion-Twin\haxe/std/php/io/File.hx">
		<getContent public="1" set="method" line="41" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes public="1" set="method" line="45" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<putContent public="1" set="method" line="49" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
</f></putContent>
		<read public="1" set="method" line="53" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="php.io.FileInput"/>
</f></read>
		<write public="1" set="method" line="57" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="php.io.FileOutput"/>
</f></write>
		<append public="1" set="method" line="61" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="php.io.FileOutput"/>
</f></append>
		<copy public="1" set="method" line="65" static="1"><f a="src:dst">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></copy>
		<stdin public="1" set="method" line="69" static="1"><f a=""><c path="php.io.FileInput"/></f></stdin>
		<stdout public="1" set="method" line="73" static="1"><f a=""><c path="php.io.FileOutput"/></f></stdout>
		<stderr public="1" set="method" line="77" static="1"><f a=""><c path="php.io.FileOutput"/></f></stderr>
		<getChar public="1" set="method" line="81" static="1"><f a="echo">
	<e path="Bool"/>
	<c path="Int"/>
</f></getChar>
		<haxe_doc>
	API for reading and writing to files.
</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="org.silex.serverApi.SiteEditor" params="" file="../../framework/hx/org/silex/serverApi/SiteEditor.hx">
		<siteEditorExtern><c path="org.silex.serverApi.externs.SiteEditorExtern"/></siteEditorExtern>
		<getSectionSeoData public="1" set="method" line="28">
			<f a="id_site:deeplink:?urlBase">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Hash"><d/></c>
			</f>
			<haxe_doc><![CDATA[
	*  Finds and returns SEO informations about a page.<br/>
	*  If several layers are composing the deeplink all data are merged.
	]]></haxe_doc>
		</getSectionSeoData>
		<writeSectionData public="1" set="method" line="55">
			<f a="xmlData:xmlFileName:sectionName:id_site:seoObject:domObject">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Hash"><c path="String"/></c>
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Writes xmlData into xmlFileName.
	</haxe_doc>
		</writeSectionData>
		<storeSeoData public="1" set="method" line="62">
			<f a="websiteContentFolderPath:sectionName:seoObject">
				<c path="String"/>
				<c path="String"/>
				<c path="Hash"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Stores seo data from seoObject in the file corresponding to sectionName and websiteContentFolderPath.
	</haxe_doc>
		</storeSeoData>
		<renameSection public="1" set="method" line="77">
			<f a="siteName:oldSectionName:newSectionName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Renames oldSectionName in siteName to newSectionName.
	</haxe_doc>
		</renameSection>
		<duplicateSection public="1" set="method" line="84">
			<f a="siteName:oldSectionName:newSectionName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Duplicates oldSectionName from siteName to newSectionName.
	</haxe_doc>
		</duplicateSection>
		<createSection public="1" set="method" line="91">
			<f a="siteName:newSectionName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Creates newSectionName in siteName.
	</haxe_doc>
		</createSection>
		<deleteSection public="1" set="method" line="98">
			<f a="siteName:sectionName">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*  Deletes sectionName in siteName.
	</haxe_doc>
		</deleteSection>
		<savePublicationStructure public="1" set="method" line="105">
			<f a="siteName:xmlContent:xmlContentPublished">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Saves xmlContent and xmlContentPublished into the corresponding files depending on siteName.
	</haxe_doc>
		</savePublicationStructure>
		<loadPublicationStructure public="1" set="method" line="112">
			<f a="siteName:?isPublishedVersion">
				<c path="String"/>
				<e path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Loads and returns either the published version or the unpublished version of PublicationStructure of siteName.
	</haxe_doc>
		</loadPublicationStructure>
		<parse_client_site_ini_file public="1" set="method" line="119">
			<f a="filePath">
				<c path="String"/>
				<c path="Hash"><c path="String"/></c>
			</f>
			<haxe_doc>
	*  Do not use, we are trying to get rid of it.
	</haxe_doc>
		</parse_client_site_ini_file>
		<getWebsiteConfig public="1" set="method" line="126">
			<f a="id_site:?mergeWithServerConfig">
				<c path="String"/>
				<e path="Bool"/>
				<t path="Null"><c path="Hash"><c path="String"/></c></t>
			</f>
			<haxe_doc>
	*  Return's id_site's configuration.
	</haxe_doc>
		</getWebsiteConfig>
		<deleteWebsite public="1" set="method" line="136">
			<f a="id_site">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Delete the whole id_site Website (Publication).
	</haxe_doc>
		</deleteWebsite>
		<createWebsite public="1" set="method" line="143">
			<f a="id_site">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Creates a new website (Publication) named id_site.
	</haxe_doc>
		</createWebsite>
		<renameWebsite public="1" set="method" line="150">
			<f a="id_site:new_id">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Renames website (Publication) from id_site to new_id.
	</haxe_doc>
		</renameWebsite>
		<writeWebsiteConfig public="1" set="method" line="157">
			<f a="websiteInfo:id_site">
				<c path="Hash"><c path="String"/></c>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	*  Saves websiteInfo.
	</haxe_doc>
		</writeWebsiteConfig>
		<duplicateWebsite public="1" set="method" line="164">
			<f a="id_site:newName">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  Duplicates id_site as newName.
	</haxe_doc>
		</duplicateWebsite>
		<getSiteThumb public="1" set="method" line="179">
			<f a="siteName">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
	*  Return type is Dynamic since it can be a php.NativeArray or a String in case of error.
	</haxe_doc>
		</getSiteThumb>
		<getPagePreview public="1" set="method" line="186">
			<f a="siteName:pageName">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
	*  Return type is Dynamic since it can be a php.NativeArray or a String in case of error.
	</haxe_doc>
		</getPagePreview>
		<new public="1" set="method" line="19"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Std" params="" file="C:\Motion-Twin\haxe/std/php/_std/Std.hx">
		<is public="1" set="method" line="28" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="32" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="36" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="40" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="49" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="53" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="php.IteratorAggregate" params="T" file="C:\Motion-Twin\haxe/std/php/IteratorAggregate.hx" extern="1" interface="1"><getIterator set="method">
	<f a=""><t path="Iterator"><c path="php.IteratorAggregate.T"/></t></f>
	<haxe_doc> 
		This method is not public to not induce haXe users to use it ;) 
		Use iterator() instead.
		The return type would be Aggregator that is unusable in haXe 
	</haxe_doc>
</getIterator></class>
	<typedef path="org.silex.core.seo.ComponentSeoModel" params="" file="../../framework/hx/org/silex/core/seo/ComponentSeoModel.hx">
		<a>
			<tags><c path="String"/></tags>
			<specificProperties><c path="Hash"><c path="String"/></c></specificProperties>
			<playerName><c path="String"/></playerName>
			<links><c path="Array"><t path="org.silex.core.seo.ComponentSeoLinkModel"/></c></links>
			<iconIsIcon><c path="String"/></iconIsIcon>
			<htmlEquivalent><c path="String"/></htmlEquivalent>
			<description><c path="String"/></description>
			<className><c path="String"/></className>
		</a>
		<haxe_doc><![CDATA[
 * class used to store all components of a specific layer & deeplink. Accessors should be kept as is.
 * 
 * @author	Raphael Harmel
 * @version 1.0
 * @date   2011-05-25
 ]]></haxe_doc>
	</typedef>
	<class path="List" params="T" file="C:\Motion-Twin\haxe/std/php/_std/List.hx">
		<implements path="php.IteratorAggregate"><c path="List.T"/></implements>
		<h><c path="ArrayAccess"><d/></c></h>
		<q><c path="ArrayAccess"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="37">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="47">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="55">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="59">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="63">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="74">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="78">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="84">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="104">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="108">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="123">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="138">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="150">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<getIterator set="method" line="161"><f a=""><t path="Iterator"><c path="List.T"/></t></f></getIterator>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<typedef path="php.FileStat" params="" file="C:\Motion-Twin\haxe/std/php/FileSystem.hx" module="php.FileSystem"><a>
	<uid><c path="Int"/></uid>
	<size><c path="Int"/></size>
	<rdev><c path="Int"/></rdev>
	<nlink><c path="Int"/></nlink>
	<mtime><c path="Date"/></mtime>
	<mode><c path="Int"/></mode>
	<ino><c path="Int"/></ino>
	<gid><c path="Int"/></gid>
	<dev><c path="Int"/></dev>
	<ctime><c path="Date"/></ctime>
	<atime><c path="Date"/></atime>
</a></typedef>
	<enum path="php.FileKind" params="" file="C:\Motion-Twin\haxe/std/php/FileSystem.hx" module="php.FileSystem">
		<kother a="k"><c path="String"/></kother>
		<kfile/>
		<kdir/>
	</enum>
	<class path="php.FileSystem" params="" file="C:\Motion-Twin\haxe/std/php/FileSystem.hx">
		<exists public="1" get="inline" set="null" line="49" static="1"><f a="path">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<rename public="1" get="inline" set="null" line="53" static="1"><f a="path:newpath">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></rename>
		<stat public="1" set="method" line="57" static="1"><f a="path">
	<c path="String"/>
	<t path="php.FileStat"/>
</f></stat>
		<fullPath public="1" get="inline" set="null" line="76" static="1"><f a="relpath">
	<c path="String"/>
	<c path="String"/>
</f></fullPath>
		<kind public="1" set="method" line="80" static="1"><f a="path">
	<c path="String"/>
	<e path="php.FileKind"/>
</f></kind>
		<isDirectory public="1" get="inline" set="null" line="89" static="1"><f a="path">
	<c path="String"/>
	<e path="Bool"/>
</f></isDirectory>
		<createDirectory public="1" get="inline" set="null" line="93" static="1"><f a="path">
	<c path="String"/>
	<unknown/>
</f></createDirectory>
		<deleteFile public="1" get="inline" set="null" line="97" static="1"><f a="path">
	<c path="String"/>
	<unknown/>
</f></deleteFile>
		<deleteDirectory public="1" get="inline" set="null" line="101" static="1"><f a="path">
	<c path="String"/>
	<unknown/>
</f></deleteDirectory>
		<readDirectory public="1" set="method" line="105" static="1"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></readDirectory>
	</class>
	<class path="php.io.FileOutput" params="" file="C:\Motion-Twin\haxe/std/php/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<__f><e path="php.io.FileHandle"/></__f>
		<writeByte public="1" set="method" line="38" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="44" override="1"><f a="b:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="52" override="1"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="57" override="1"><f a=""><e path="Void"/></f></close>
		<seek public="1" set="method" line="62"><f a="p:pos">
	<c path="Int"/>
	<e path="php.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" set="method" line="73"><f a=""><c path="Int"/></f></tell>
		<eof public="1" set="method" line="79"><f a=""><e path="Bool"/></f></eof>
		<new public="1" set="method" line="34"><f a="f">
	<e path="php.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [php.io.File.write] to create a [FileOutput]
</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="C:\Motion-Twin\haxe/std/php/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="C:\Motion-Twin\haxe/std/php/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="15" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="35" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="42" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="50" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="56" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="60" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="68" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="76" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="84" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="109" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="121" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="127" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="146" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="163" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="169" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="193" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="213" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="217" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="224" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="haxe.io.Eof" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	This exception is raised when reading while data is no longer available in the [Input].
</haxe_doc>
	</class>
	<class path="php.NativeString" params="" file="C:\Motion-Twin\haxe/std/php/NativeString.hx" extern="1"/>
	<class path="php.io.FileInput" params="" file="C:\Motion-Twin\haxe/std/php/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<__f><e path="php.io.FileHandle"/></__f>
		<readByte public="1" set="method" line="40" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="47" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="56" override="1"><f a=""><e path="Void"/></f></close>
		<seek public="1" set="method" line="61"><f a="p:pos">
	<c path="Int"/>
	<e path="php.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" set="method" line="72"><f a=""><c path="Int"/></f></tell>
		<readLine public="1" set="method" line="78" override="1"><f a=""><c path="String"/></f></readLine>
		<new public="1" set="method" line="36"><f a="f">
	<e path="php.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [php.io.File.read] to create a [FileInput]
</haxe_doc>
	</class>
	<class path="Class" params="T" file="C:\Motion-Twin\haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="org.silex.core.seo.Utils" params="" file="../../framework/hx/org/silex/core/seo/Utils.hx">
		<TITLE_SEPARATOR line="30" static="1"><c path="String"/></TITLE_SEPARATOR>
		<DESCRIPTION_SEPARATOR line="31" static="1"><c path="String"/></DESCRIPTION_SEPARATOR>
		<TAGS_SEPARATOR line="32" static="1"><c path="String"/></TAGS_SEPARATOR>
		<HTML_EQUIVALENT_SEPARATOR line="33" static="1"><c path="String"/></HTML_EQUIVALENT_SEPARATOR>
		<getPageSeoData public="1" set="method" line="65" static="1">
			<f a="idSite:deeplink:?urlBase">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="org.silex.core.seo.LayerSeoAggregatedModel"/>
			</f>
			<haxe_doc>
	 * This method is used to get the seo informations of a specific page.
	 * A page can be defined by multiple layers like /start/child/grandChild
	 * 
	 * @param	id_site
	 * @param	deeplink
	 * @param	?urlBase
	 * @return
	 </haxe_doc>
		</getPageSeoData>
		<getPageSeoDataAsPhpArray public="1" set="method" line="151" static="1">
			<f a="idSite:deeplink:?urlBase">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="php.NativeArray"/>
			</f>
			<haxe_doc>
	 * This method is used to get the seo informations of a specific page.
	 * A page can be defined by multiple layers like /start/child/grandChild
	 * 
	 * @param	id_site
	 * @param	deeplink
	 * @param	?urlBase
	 * @return
	 </haxe_doc>
		</getPageSeoDataAsPhpArray>
		<aggregateLayerSeoData public="1" set="method" line="165" static="1">
			<f a="layerSeo:deeplink:?urlBase">
				<t path="org.silex.core.seo.LayerSeoModel"/>
				<c path="String"/>
				<c path="String"/>
				<t path="org.silex.core.seo.LayerSeoAggregatedModel"/>
			</f>
			<haxe_doc>
	 * This methods takes a LayerSeoModel and aggregates its component seo data
	 * 
	 * @param	layerSeo
	 </haxe_doc>
		</aggregateLayerSeoData>
		<layerSeoAggregatedModel2PhpArray public="1" set="method" line="222" static="1">
			<f a="layerSeoAggregatedModel">
				<t path="org.silex.core.seo.LayerSeoAggregatedModel"/>
				<c path="php.NativeArray"/>
			</f>
			<haxe_doc>
	 * converts a LayerSeoAggregatedModel to a Php Native Array.
	 * 
	 * inputs: a LayerSeoAggregatedModel
	 * output: an Php Native Array
	 </haxe_doc>
		</layerSeoAggregatedModel2PhpArray>
		<createComponentSeoModel public="1" set="method" line="269" static="1">
			<f a=""><t path="org.silex.core.seo.ComponentSeoModel"/></f>
			<haxe_doc>
	*  This function creates an object completely instanciated that correspond to the type ComponentSeoModel.
	</haxe_doc>
		</createComponentSeoModel>
		<haxe_doc>
 * class used to gather utility methods concerning SEO
 * 
 * @author	Raphael Harmel
 * @version 1.0
 * @date   2011-07-12
 </haxe_doc>
	</class>
	<class path="String" params="" file="C:\Motion-Twin\haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="Array" params="T" file="C:\Motion-Twin\haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="org.silex.core.XmlUtils" params="" file="../../framework/hx/org/silex/core/XmlUtils.hx">
		<INDENT_STRING get="inline" set="null" line="26" static="1"><c path="String"/></INDENT_STRING>
		<cleanUp public="1" set="method" line="33" static="1">
			<f a="xml">
				<c path="Xml"/>
				<c path="Xml"/>
			</f>
			<haxe_doc><![CDATA[
	*  This method takes an XML, removes white spaces, indent & comments, and then return the XML.
	*  For now it just calling the equivalent recursive method.
	*  It is better to have two methods for recursive algorithms, one to initialise recursion, the other for recursion
	]]></haxe_doc>
		</cleanUp>
		<cleanUpRecursive set="method" line="42" static="1">
			<f a="xml">
				<c path="Xml"/>
				<c path="Xml"/>
			</f>
			<haxe_doc><![CDATA[
	*  This method takes an XML, removes white spaces, indent & comments, and then return the XML. To be called by cleanUp(xml) and not directly.
	]]></haxe_doc>
		</cleanUpRecursive>
		<stringIndent2Xml public="1" set="method" line="107" static="1">
			<f a="xmlString">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
	*  This method takes an XML String (indented or not), and returns the cleaned XML.
	</haxe_doc>
		</stringIndent2Xml>
		<xml2StringIndent public="1" set="method" line="116" static="1">
			<f a="xml">
				<c path="Xml"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  This method takes an XML object and returns the indented string equivalent.
	</haxe_doc>
		</xml2StringIndent>
		<xml2StringIndentRecursive set="method" line="126" static="1">
			<f a="xml:?indentationLevel">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	*  This method takes an XML object and returns the indented string equivalent. to be called by xml2StringIndent(xml) and not directly.
	</haxe_doc>
		</xml2StringIndentRecursive>
		<Xml2Dynamic public="1" set="method" line="182" static="1">
			<f a="xml:?oofLegacyWorkaround">
				<c path="Xml"/>
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>
	*  This method takes an XML object and returns the equivalent Dynamic.
	* 
	* input:	a Xml
	* output:	a dynamic
	* 
	</haxe_doc>
		</Xml2Dynamic>
		<xml2DynamicRecursive set="method" line="203" static="1">
			<f a="xml:isRss:oofLegacyWorkaround">
				<c path="Xml"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>
	*  This method takes an XML object and returns the equivalent Dynamic.
	*  To be called by xml2StringIndent(xml) and not directly.
	* 
	* input:	a Xml
	* output:	a dynamic
	* 
	</haxe_doc>
		</xml2DynamicRecursive>
		<haxe_doc>
 * This class gathers XML utilities
 * 
 * @author Raphael Harmel
 * @version 1.0
 * @date   2011-01-19
 * 
 </haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Motion-Twin\haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="org.silex.serverApi.ServerConfig" params="" file="../../framework/hx/org/silex/serverApi/ServerConfig.hx">
		<serverConfigInstance><c path="org.silex.serverApi.externs.ServerConfigExtern"/></serverConfigInstance>
		<silexServerIni public="1" get="getSilexServerIni" set="null">
			<c path="Hash"><c path="String"/></c>
			<haxe_doc><![CDATA[
	*  Stores the server's configuration.<br/>
	*  Changes in it won't be reflected. (Consider it immutable.)
	]]></haxe_doc>
		</silexServerIni>
		<silexClientIni public="1" get="getSilexClientIni" set="null">
			<c path="Hash"><c path="String"/></c>
			<haxe_doc><![CDATA[
	*  Stores the client's configuration. These properties are sent to the client.<br/>
	*  Changes in it won't be reflected. (Consider it immutable.)
	]]></haxe_doc>
		</silexClientIni>
		<adminWriteOk public="1" get="getAdminWriteOk" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc><![CDATA[
	*  Stores a list of files and folders that can be written by a user with Admin Role.<br/>
	*  Changes in it won't be reflected. (Consider it immutable.)
	]]></haxe_doc>
		</adminWriteOk>
		<adminReadOk public="1" get="getAdminReadOk" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>
	*  Stores a list of files and folders that can be read by a user with Admin Role.
	*  Changes in it won't be reflected. (Consider it immutable.)
	</haxe_doc>
		</adminReadOk>
		<userWriteOk public="1" get="getUserWriteOk" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>
	*  Stores a list of files and folders that can written by a user with User Role.
	*  Changes in it won't be reflected. (Consider it immutable.)
	</haxe_doc>
		</userWriteOk>
		<userReadOk public="1" get="getUserReadOk" set="null">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>
	*  Stores a list of files and folders that can be read by a user User Role.
	*  Changes in it won't be reflected. (Consider it immutable.)
	</haxe_doc>
		</userReadOk>
		<sepCharForDeeplinks public="1" get="getSepCharForDeeplinks" set="null">
			<c path="String"/>
			<haxe_doc>
	*  The character used to replace spaces in URLs.
	</haxe_doc>
		</sepCharForDeeplinks>
		<getSilexServerIni set="method" line="61"><f a=""><c path="Hash"><c path="String"/></c></f></getSilexServerIni>
		<getSilexClientIni set="method" line="66"><f a=""><c path="Hash"><c path="String"/></c></f></getSilexClientIni>
		<getAdminWriteOk set="method" line="71"><f a=""><c path="Array"><c path="String"/></c></f></getAdminWriteOk>
		<getAdminReadOk set="method" line="76"><f a=""><c path="Array"><c path="String"/></c></f></getAdminReadOk>
		<getUserWriteOk set="method" line="81"><f a=""><c path="Array"><c path="String"/></c></f></getUserWriteOk>
		<getUserReadOk set="method" line="86"><f a=""><c path="Array"><c path="String"/></c></f></getUserReadOk>
		<getSepCharForDeeplinks set="method" line="91"><f a=""><c path="String"/></f></getSepCharForDeeplinks>
		<getContentFolderForPublication public="1" set="method" line="102">
			<f a="id_publication">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[
	*  Returns the String representing the content folder of the publication which id is given as parameter.<br/>
	*  For example it may return "contents/".<br/>
	*  Values of CONTENTS_THEMES_FOLDER, CONTENTS_UTILITIES_FOLDER and CONTENT_FOLDER are set in
	*  conf/silex_server.ini.
	]]></haxe_doc>
		</getContentFolderForPublication>
		<new public="1" set="method" line="19"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="org.silex.core.seo.LayerSeoModel" params="" file="../../framework/hx/org/silex/core/seo/LayerSeoModel.hx">
		<a>
			<title><c path="String"/></title>
			<pubDate><c path="String"/></pubDate>
			<description><c path="String"/></description>
			<components><c path="Array"><t path="org.silex.core.seo.ComponentSeoModel"/></c></components>
		</a>
		<haxe_doc>
 * class used to describe the v2 layer seo structure for a single deeplink.
 * a layer seo xml file can contain multiple LayerSeoVO, one for each deeplink.
 * 
 * @author	Raphael Harmel
 * @version 1.0
 * @date   2011-05-25
 </haxe_doc>
	</typedef>
	<class path="php.Exception" params="" file="C:\Motion-Twin\haxe/std/php/Exception.hx" extern="1">
		<message><c path="String"/></message>
		<code><c path="Int"/></code>
		<file><c path="String"/></file>
		<line><c path="Int"/></line>
		<getMessage public="1" set="method"><f a=""><c path="String"/></f></getMessage>
		<getCode public="1" set="method"><f a=""><c path="Int"/></f></getCode>
		<getFile public="1" set="method"><f a=""><c path="String"/></f></getFile>
		<getLine public="1" set="method"><f a=""><c path="Int"/></f></getLine>
		<getTrace public="1" set="method"><f a=""><c path="Array"><c path="String"/></c></f></getTrace>
		<getTraceAsString public="1" set="method"><f a=""><c path="String"/></f></getTraceAsString>
		<__toString public="1" set="method"><f a=""><c path="String"/></f></__toString>
		<new public="1" set="method"><f a="?message:?code">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\Motion-Twin\haxe/std/haxe/io/BytesData.hx"><c path="php.NativeString"/></typedef>
	<class path="Hash" params="T" file="C:\Motion-Twin\haxe/std/php/_std/Hash.hx">
		<implements path="php.IteratorAggregate"><c path="Hash.T"/></implements>
		<h><c path="ArrayAccess"><c path="Hash.T"/></c></h>
		<set public="1" set="method" line="33">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="37">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="44">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="48">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="60">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<getIterator set="method" line="81">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Implement IteratorAggregate for native php iteration
	</haxe_doc>
		</getIterator>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="Main" params="" file="src/Main.hx">
		<main public="1" set="method" line="15" static="1"><f a=""><e path="Void"/></f></main>
		<haxe_doc>
 * ...
 * @author Raphael Harmel
 </haxe_doc>
	</class>
</haxe>