/*This file is part of Silex - see http://projects.silexlabs.org/?/silex

Silex is Â© 2010-2011 Silex Labs and is released under the GPL License:

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License (GPL) as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. 

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

To read the license please visit http://www.gnu.org/copyleft/gpl.html
*/
package org.silex.publication;

using StringTools;

/**
*  This class is the parser used to parse and create PublicationStructure objects' XML representation.
*/
class PublicationStructureParser
{
	/**
	*  This method takes a PublicationStructure object and returns its XML representation.
	*/
	public static function ps2XML(ps : PublicationStructureModel) : Xml
	{
		var xml = Xml.createDocument();
		xml.addChild(Xml.createProlog('xml version="1.0"'));
		xml.addChild(Xml.createComment("This file has been generated by org.silex.publication.PublicationStructureParser"));
		var psNode = Xml.createElement("ps");
		psNode.set("hasCover", Std.string(ps.hasCover));
		psNode.set("hasDoublePages", Std.string(ps.hasDoublePages));
		xml.addChild(psNode);
		for(p in ps.pages)
		{
			var pageNode = Xml.createElement("page");
			var nameNode = Xml.createElement("name");
			nameNode.addChild(Xml.createCData(p.name));
			pageNode.addChild(nameNode);
			
			var titleNode = Xml.createElement("title");
			titleNode.addChild(Xml.createCData(p.title));
			pageNode.addChild(titleNode);
			
			var descriptionNode = Xml.createElement("description");
			descriptionNode.addChild(Xml.createCData(p.description));
			pageNode.addChild(descriptionNode);
			
			var deeplinkNode = Xml.createElement("deeplink");
			deeplinkNode.addChild(Xml.createCData(p.deeplink));
			pageNode.addChild(deeplinkNode);
			
			//keywords
			var keywordsNode = Xml.createElement("keywords");
			keywordsNode.addChild(Xml.createCData(p.keywords.join(",")));
			pageNode.addChild(keywordsNode);
			
			//tags
			var tagsNode = Xml.createElement("tags");
			tagsNode.addChild(Xml.createCData(p.tags.join(",")));
			pageNode.addChild(tagsNode);
			
			var pageLeftNumberNode = Xml.createElement("pageLeftNumber");
			pageLeftNumberNode.addChild(Xml.createCData(Std.string(p.pageLeftNumber)));
			pageNode.addChild(pageLeftNumberNode);
			
			var pageRightNumberNode = Xml.createElement("pageRightNumber");
			pageRightNumberNode.addChild(Xml.createCData(Std.string(p.pageRightNumber)));
			pageNode.addChild(pageRightNumberNode);
			
			var enabledNode = Xml.createElement("enabled");
			enabledNode.addChild(Xml.createCData(Std.string(p.enabled)));
			pageNode.addChild(enabledNode);
			
			psNode.addChild(pageNode);
		}
		return xml;
	}
	
	/**
	*  This method takes an XML representation of a PublicationStructure and returns a PublicationStructure object.
	*/
	public static function xml2PS(xml : Xml) : PublicationStructureModel
	{
		var structure = new PublicationStructureModel();
		var i = 0;
		var pages = xml.firstElement().elementsNamed("page");
		for(p in pages)
		{
			i++;
			var tmpNode : Xml;
			var page = new PageModel();
			page.index = i;
			//Name
			if((tmpNode = p.elementsNamed("name").next()).iterator().hasNext())
				page.name = tmpNode.firstChild().nodeValue;
			//Title
			if((tmpNode = p.elementsNamed("title").next()).iterator().hasNext())
				page.title = tmpNode.firstChild().nodeValue;
			//Deeplink
			if((tmpNode = p.elementsNamed("deeplink").next()).iterator().hasNext())
				page.deeplink = tmpNode.firstChild().nodeValue;
			//Keywords
			if((tmpNode = p.elementsNamed("keywords").next()).iterator().hasNext())
				for(word in tmpNode.firstChild().nodeValue.split(","))
					page.keywords.add(word.ltrim().rtrim());

			//Tags
			if((tmpNode = p.elementsNamed("tags").next()).iterator().hasNext())
				for(word in tmpNode.firstChild().nodeValue.split(","))
					page.keywords.add(word.ltrim().rtrim());

			//PageLeftNumber
			if((tmpNode = p.elementsNamed("pageLeftNumber").next()).iterator().hasNext())
				page.pageLeftNumber = Std.parseInt(tmpNode.firstChild().nodeValue);
			//PageRightNumber
			if((tmpNode = p.elementsNamed("pageRightNumber").next()).iterator().hasNext())
				page.pageRightNumber = Std.parseInt(tmpNode.firstChild().nodeValue);
			//Enabled
			if((tmpNode = p.elementsNamed("enabled").next()).iterator().hasNext())
				page.enabled = switch(tmpNode.firstChild().nodeValue.toLowerCase())
										{
											case "true":
												true;
											case "false":
												false;
											default:
												throw "Incorrect enabled value";
										};
			structure.pages.push(page);
		}
		
		//hasCover
		structure.hasCover = switch(xml.firstElement().get("hasCover"))
								{
									case "false":
										false;
									default:
										true;
								};
		//hasDoublePages (triggers structure.recalculatePagesNumbers)
		structure.hasDoublePages = switch(xml.firstElement().get("hasDoublePages"))
								{
									case "false":
										false;
									default:
										true;
								};
		return structure;
	}
}